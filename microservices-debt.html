<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light" />
    <meta name="generator" content="Marmite Retro Edition" />

    <title>Microservices: Hidden Technical Debt (and how to possibly avoid the traps) - Pedro Lopes</title>

    
<meta property="og:title" content="Microservices: Hidden Technical Debt (and how to possibly avoid the traps)">
<meta property="og:description" content=" Introduction These days, I keep seeing microservices being treated as the answer to every software ...">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Pedro Lopes">


<meta property="article:author" content="Pedro Lopes">



    <!-- Retro Theme Styles -->
    <link rel="stylesheet" href="./static/css/retro-theme.css">
    <link rel="stylesheet" href="./static/css/windows95.css">
    <link rel="stylesheet" href="./static/css/curve-inspired.css">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="./static/favicon.ico">

    
</head>
<body>
    <!-- Desktop with Retro Background -->
    <div class="desktop-wrapper">
        <!-- Main Window Chrome -->
        <div class="window-chrome">
            <!-- Title Bar -->
            <div class="title-bar">
                <span class="title-text">
                    Pedro Lopes - Microservices: Hidden Technical Debt (and how to possibly avoid the traps)
                </span>
                <div class="window-controls">
                    <button class="btn-minimize" aria-label="Minimize">_</button>
                    <button class="btn-maximize" aria-label="Maximize">‚ñ°</button>
                    <button class="btn-close" aria-label="Close">√ó</button>
                </div>
            </div>

            <!-- Menu Bar / Navigation -->
            <nav class="menu-bar">
                <a href="https://pedroca.xyz">Home</a>
                
                <a href="tags.html">Tags</a>
                
                <a href="archive.html">Archive</a>
                
                <a href="authors.html">Authors</a>
                
            </nav>

            <!-- Main Content Area -->
            <main class="content-area">
                
<article class="window-panel">
    <!-- Post Header -->
    <header class="post-header">
        <h1 class="post-title">Microservices: Hidden Technical Debt (and how to possibly avoid the traps)</h1>

        <div class="post-meta">
            

            
            <span class="post-author">
                üë§ by <a href="author-pedrohbl_.html">Pedro Lopes</a>
            </span>
            

            
            <div class="post-tags">
                
                
                <a href="tag-microservices.html" class="retro-badge">microservices</a>
                
                
                <a href="tag-technical-debt.html" class="retro-badge">technical-debt</a>
                
                
                <a href="tag-distributed-systems.html" class="retro-badge">distributed-systems</a>
                
                
                <a href="tag-software-architecture.html" class="retro-badge">software-architecture</a>
                
            </div>
            
        </div>
    </header>

    <!-- Post Content -->
    <div class="post-content">
        <p>Feb 8, 2025 - ‚ßñ 9 min</p>
<h2 id="introduction">Introduction</h2>
<p>These days, I keep seeing microservices being treated as the answer to every software problem. Having worked with various architectures throughout my career, I've noticed how many players often jump into microservices without considering the long-term implications. It reminds me of a project where we turned a perfectly functional monolith into a distributed system just because "that's what modern companies do."</p>
<p>But here's the thing: microservices aren't a silver bullet. In fact, they can become a massive technical debt that's incredibly hard to pay off. Matt Ranney, DoorDash's Scalability Engineer Lead, makes this point brilliantly in his talk "Microservices are Technical Debt." After experiencing similar challenges, I decided to dive into this topic, including some cientific papers that covered similar issues like "Microservices Anti-Patterns: A Taxonomy," to understand what's really going on.</p>
<p>In this post, I'll try to cover:</p>
<ol>
<li>Why microservices are often misunderstood and misused</li>
<li>Common anti-patterns I've encountered (and how to avoid them)</li>
<li>Evidence-based approaches to build systems that actually work</li>
</ol>
<h2 id="the-overuse-of-microservices">The Overuse of Microservices</h2>
<h3 id="why-do-we-default-to-microservices">Why Do We Default to Microservices?</h3>
<ol>
<li>
<p><strong>The Hype Factor</strong></p>
</li>
<li>
<p>Companies often adopt microservices because it's trendy, without analyzing their actual needs.</p>
</li>
<li><strong>Example:</strong> Imagine you‚Äôre at a startup trying to attract investors. Your team decides to split a simple app into 10 microservices just to showcase "scalability." Fast forward six months: you‚Äôre drowning in Kubernetes configurations and service mesh setups, while competitors with monoliths ship features twice as fast.</li>
<li>
<p><strong>The Independence Illusion</strong></p>
</li>
<li>
<p>While microservices promise independent teams and deployments, this only works with proper service boundaries.</p>
</li>
<li><strong>Example:</strong> Picture working on a user service. You update a field in the <code>UserProfile</code> class, only to discover the notifications service crashes because it hardcoded a dependency on the old field structure. Now you‚Äôre stuck updating three services for what should have been a simple change.</li>
<li>
<p><strong>The Monolith Misconception</strong></p>
</li>
<li>
<p>I've noticed a strange fear of monoliths in the industry. But here's what I've learned: for many applications, a well-structured modular monolith is actually the better choice.</p>
</li>
<li><strong>Example:</strong> A software development team spent months breaking their monolith into microservices, only to realize they had created a <strong>distributed monolith</strong>‚Äîa system that was just as hard to manage, but with added complexity. What if it was just a simplified collection of function calls instead of a bunch of meaningless HTTP calls?</li>
</ol>
<h2 id="microservices-as-technical-debt">Microservices as Technical Debt</h2>
<p>Matt Ranney makes a compelling case for why microservices can be considered <strong>technical debt</strong>. Here‚Äôs why:</p>
<ol>
<li><strong>Initial Speed, Long-Term Pain</strong></li>
<li>Microservices can speed up development in the short term, but they often lead to long-term maintenance challenges.</li>
<li><strong>Example:</strong> Imagine you‚Äôre building a feature to let users reset passwords. You start with a simple service:</li>
</ol>
<div class="codehilite"><pre><span></span><code>    public void resetPassword(String userId, String newPassword) {
         User user = userService.getUser(userId);
         try{
           userService.updateProfile(user, newPassword);
         }
     }
</code></pre></div>

<p>But obviously the requirements grow and now this evolves into:</p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="c1">// look at the complexity added to the same function</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">userService</span><span class="p">.</span><span class="n">updateProfile</span><span class="p">(</span><span class="nb">user</span><span class="p">,</span><span class="w"> </span><span class="n">newPassword</span><span class="p">);</span>
<span class="w">      </span><span class="n">notificationService</span><span class="p">.</span><span class="n">notifyProfileUpdate</span><span class="p">(</span><span class="nb">user</span><span class="p">.</span><span class="n">getId</span><span class="p">());</span>
<span class="w">      </span><span class="n">authService</span><span class="p">.</span><span class="n">refreshUserSession</span><span class="p">(</span><span class="nb">user</span><span class="p">.</span><span class="n">getId</span><span class="p">());</span>
<span class="w">      </span><span class="n">analyticsService</span><span class="p">.</span><span class="n">trackProfileUpdate</span><span class="p">(</span><span class="nb">user</span><span class="p">.</span><span class="n">getId</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">ServiceException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// now you need complex rollback logic =D</span>
<span class="w">      </span><span class="n">compensationService</span><span class="p">.</span><span class="n">handleFailure</span><span class="p">(</span><span class="nb">user</span><span class="p">.</span><span class="n">getId</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;PROFILE_UPDATE&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>

<p>Now, a simple password reset requires four services to work perfectly together. Miss one, and you‚Äôve got angry users or security holes and a fresh war room to deal.</p>
<h2 id="2-the-distributed-monolith-trap">2. The Distributed Monolith Trap</h2>
<p>Let‚Äôs get real: most companies end up with distributed monoliths, not true microservices. Here‚Äôs why this happens and why it‚Äôs worse than a traditional monolith.</p>
<h3 id="practical-example-the-loyalty-points-nightmare">Practical Example: The Loyalty Points Nightmare</h3>
<p>Imagine you‚Äôre working on an e-commerce system. You need to add a <code>loyaltyPoints</code> field to user profiles. Here‚Äôs what happens:</p>
<ol>
<li><strong>User Service:</strong></li>
</ol>
<p><code>public class User {
       private String id;
       private int loyaltyPoints; // New field
   }</code>
2. <strong>Payments Service:</strong></p>
<p><code>public class PaymentProcessor {
       public void applyDiscount(String userId) {
           User user = userService.getUser(userId);
           if (user.getLoyaltyPoints() &gt; 1000) { // Now depends on User's new field
               applyDiscount();
           }
       }
   }</code>
3. <strong>Analytics Service:</strong></p>
<p><code>public class Analytics {
       public void trackPurchase(String userId) {
           User user = userService.getUser(userId);
           log("Purchase by user with " + user.getLoyaltyPoints() + " points");
       }
   }</code></p>
<p>Suddenly, updating a single field requires:</p>
<ul>
<li>Coordinating deployments across three teams</li>
<li>Ensuring all services update dependencies simultaneously</li>
<li>Risking system-wide failures if any service lags</li>
</ul>
<p>This is the distributed monolith trap‚Äîa system with all the complexity of microservices but none of the benefits. As Newman (2021) notes, this anti-pattern is rampant in teams that prioritize speed over thoughtful design.</p>
<h2 id="3-hidden-costs-of-microservices">3. Hidden Costs of Microservices</h2>
<ul>
<li>Microservices introduce hidden costs, such as network latency, service discovery, and inter-service communication.</li>
<li><strong>Example:</strong> Imagine you‚Äôre debugging why user sessions expire randomly. After days of checking code, you discover a 200ms delay between the auth service and session service. The timeout configuration didn‚Äôt account for this latency, causing sporadic failures. The fix? Hours and hours wasted of meaningless debugging time, as the root cause for the problem was a bad-optimized code deployed by the auth team.</li>
</ul>
<hr />
<h2 id="common-anti-patterns-in-microservices">Common Anti-Patterns in Microservices</h2>
<p>The paper <em>Microservices Anti-Patterns: A Taxonomy</em> by Taibi et al. (2018) provides a solid framework for understanding these issues. Here are some key anti-patterns and real-world examples:</p>
<h3 id="1-the-shared-database-anti-pattern">1. <strong>The Shared Database Anti-Pattern</strong></h3>
<ul>
<li>One of the most common mistakes is sharing databases between microservices. This creates tight coupling and defeats the purpose of having independent services.</li>
<li><strong>Example:</strong> Imagine you‚Äôre working on a notifications service that shares a database with the user service:</li>
</ul>
<div class="codehilite"><pre><span></span><code>   -- Both services read from the same table
   SELECT email FROM users WHERE id = &#39;123&#39;;
</code></pre></div>

<ul>
<li>When the user service adds a new <code>is_email_verified</code> column and starts deleting unverified accounts, your notifications service starts failing because it wasn‚Äôt updated to handle the new logic.</li>
</ul>
<h3 id="2-hardcoded-urls-and-tight-coupling">2. <strong>Hardcoded URLs and Tight Coupling</strong></h3>
<ul>
<li>Hardcoding URLs or endpoints between services is a recipe for disaster. It creates tight coupling and makes the system more fragile.</li>
<li><strong>Example:</strong> Picture this code in your payments service:</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="w">   </span><span class="c1">// Bad: Hardcoded URL</span>
<span class="w">   </span><span class="n">String</span><span class="w"> </span><span class="n">userServiceUrl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;http://user-service-prod:8080/api/users&quot;</span><span class="p">;</span>
</code></pre></div>

<ul>
<li>When you try to test this service locally, it fails because it can‚Äôt reach the production user service.</li>
</ul>
<h3 id="3-the-too-many-services-problem">3. <strong>The "Too Many Services" Problem</strong></h3>
<ul>
<li>This one is a classig example... Splitting your system into too many tiny services can lead to chaos. Each service adds overhead in terms of deployment, monitoring, and maintenance.</li>
<li><strong>Example:</strong> Imagine you‚Äôre working on a food delivery app with these services:</li>
<li><code>user-service</code></li>
<li><code>restaurant-service</code></li>
<li><code>menu-service</code> (for restaurant menus)</li>
<li><code>menu-item-service</code> (for individual dishes)</li>
<li><code>menu-category-service</code> (for dish categories)</li>
</ul>
<p>Now, displaying a restaurant‚Äôs menu requires calls to three services. A simple feature like adding a new dish category takes weeks to implement across teams.</p>
<h3 id="4-lack-of-governance">4. <strong>Lack of Governance</strong></h3>
<ul>
<li>Without proper guidelines, teams end up creating services that overlap or don‚Äôt integrate well.</li>
<li><strong>Example:</strong> A very known company had two teams building nearly identical services because there was no governance in place to coordinate their efforts.</li>
</ul>
<hr />
<h2 id="solutions-and-best-practices">Solutions and Best Practices</h2>
<p>So, how do we avoid these pitfalls? First, it's important to recognize that both monolith decomposition and microservices modeling are complex fields, extensively studied in research and industry, but in general here are some widely adopted strategies:</p>
<h3 id="1-monolith-first">1. <strong>Monolith First</strong></h3>
<ul>
<li>As Martin Fowler suggests, <em>"monolith first."</em> Build a monolith, and only split it into microservices when necessary.</li>
<li><strong>Example:</strong> Imagine you‚Äôre building a new fitness tracking app. Start with a monolith:</li>
</ul>
<div class="codehilite"><pre><span></span><code>   public class Workout {
      private String userId;
      private LocalDateTime startTime;
      private int durationMinutes;
   }
</code></pre></div>

<ul>
<li>
<p><strong>Only split into microservices when</strong>:</p>
</li>
<li>
<p>Different components have clearly different scaling needs.</p>
</li>
<li>Teams are large enough to justify separate ownership.</li>
<li>There's a structured governance process in your company over building decoupled services.</li>
<li>Automated tests are available for each service.</li>
<li>Automated deployments are available for each service.</li>
<li>Live monitoring, distributed tracing and health checks are available for each service.</li>
<li>Automated rollback during deployment are also available for each service.</li>
</ul>
<h3 id="2-domain-driven-design-ddd">2. <strong>Domain-Driven Design (DDD)</strong></h3>
<ul>
<li>Define clear boundaries for each service based on business domains. This helps avoid tight coupling and ensures that services are truly independent.</li>
<li><strong>Example:</strong> For an e-commerce platform:</li>
<li><strong>Bounded Context:</strong> Payments</li>
<li><strong>Bounded Context:</strong> Inventory</li>
<li><strong>Bounded Context:</strong> Shipping</li>
</ul>
<p>Each context has its own database and API boundaries. Changes to payment logic don‚Äôt affect shipping =D.</p>
<h3 id="3-the-reverse-conway-maneuver">3. <strong>The Reverse Conway Maneuver</strong></h3>
<ul>
<li>The <strong>Conway‚Äôs Law</strong> states that organizations design systems that mirror their communication structures. The <strong>Reverse Conway Maneuver</strong> flips this around: design your teams to match the architecture you want, basically, the teams designing a go-to system architecture based on current needs, tech debts and throttles. Just like a "reference architecture" based on reverse engineering. This way you have clear boundaries designed for each team and let they execute their goal software architecture independently.</li>
<li><strong>Example:</strong> Consider a given company X, instead of having frontend, backend, and ops teams working in silos, they restructured teams around business capabilities: a 'Payments Team' owning both backend and UI for payments, and a 'Shipping Team' handling logistics end-to-end. This allowed them to scale services independently while keeping architecture cohesive.</li>
</ul>
<hr />
<h2 id="conclusion">Conclusion</h2>
<p>I didn't mean to be the devil‚Äôs advocate here, but I tried to highlight some key points because, in many cases, the direction that microservices adoption takes ends up being unsustainable. That‚Äôs why it‚Äôs crucial to pay attention to the trade-offs and pitfalls discussed.</p>
<p>This is not supposed to be an exhaustive analysis‚Äîfar from it. As microservices, technical debt, and distributed architectures are vast and evolving fields, hundreds of thousands of cientific papers already discussed these topics. My goal was to cover some of the major issues I‚Äôve encountered, and hopefully, this discussion helps you navigate the complexities of microservices with a more critical perspective.</p>
<hr />
<h2 id="references">References</h2>
<ol>
<li>Matt Ranney, <em>Microservices are Technical Debt</em> <a href="https://www.youtube.com/watch?v=LcJKxPXYudE">link</a>.</li>
<li>Taibi et al., <em>Microservices Anti-Patterns: A Taxonomy</em> (2018).</li>
<li>Martin Fowler, <em>Monolith First</em> <a href="https://martinfowler.com/bliki/MonolithFirst.html">link</a>.</li>
<li>
<p>Conway‚Äôs Law and the Reverse Conway Maneuver (Various Sources).</p>
</li>
<li>
<p><a href="author-pedrohbl_.html"><img alt="Pedro Lopes" src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" />
  Pedro Lopes</a></p>
</li>
</ol>
<p>Feb 8, 2025 - ‚ßñ 9 min</p>
<ul>
<li><a href="./tag-microservices.html">microservices</a></li>
<li><a href="./tag-technical-debt.html">technical-debt</a></li>
<li><a href="./tag-distributed-systems.html">distributed-systems</a></li>
<li><a href="./tag-software-architecture.html">software-architecture</a></li>
</ul>
    </div>

    <!-- Post Footer with Navigation -->
    
    <footer class="post-footer" style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.1);">
        <div style="display: flex; justify-content: space-between; gap: 1rem;">
            
            <a href="multiple-lambda.html" class="button" style="flex: 1;">
                ‚Üê How to trigger multiple AWS lambdas from a single S3 operation (Terraform approach)
            </a>
            

            
            <a href="lambda-throttling.html" class="button" style="flex: 1; text-align: right;">
                Understanding and Mitigating AWS Lambda Throttling in High-Concurrency Workloads ‚Üí
            </a>
            
        </div>
    </footer>
    

    <!-- Author Info -->
    
    <div class="curve-card" style="margin-top: 2rem; padding: 1.5rem;">
        <h3>About the Author</h3>
        <div style="display: flex; gap: 1rem; align-items: center;">
            
            <img src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" alt="Pedro Lopes" style="width: 60px; height: 60px; border-radius: 50%;">
            
            <div>
                <strong>Pedro Lopes</strong>
                <p style="margin: 0.5rem 0; color: var(--text-secondary);">Software Engineer =D</p>
                
                <div style="display: flex; gap: 0.5rem;">
                    
                    <a href="https://www.linkedin.com/in/pedro-lopes-4563a7196/" class="retro-badge" target="_blank" rel="noopener">Linkedin</a>
                    
                </div>
                
            </div>
        </div>
    </div>
    
</article>

<!-- Related Posts (if available) -->


            </main>

            <!-- Footer / Status Bar -->
            <footer class="status-bar">
                <div>Powered by <a href="https://github.com/rochacbruno/marmite">Marmite</a> | <small><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY_NC-SA</a></small></div>
            </footer>
        </div>
    </div>

    <!-- Retro Effects & Main JavaScript -->
    <script src="./static/js/retro-effects.js"></script>
    <script src="./static/js/main.js"></script>

    
</body>
</html>