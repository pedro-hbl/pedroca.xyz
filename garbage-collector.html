<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light" />
    <meta name="generator" content="Marmite Retro Edition" />

    <title>Choosing a Garbage Collector for Your Java/Kotlin Application: Things I Wish I Knew Back Then - Pedro Lopes</title>

    
<meta property="og:title" content="Choosing a Garbage Collector for Your Java/Kotlin Application: Things I Wish I Knew Back Then">
<meta property="og:description" content=" Introduction When I first started building Java and Kotlin applications, I didn‚Äôt really pay much a...">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Pedro Lopes">


<meta property="article:author" content="Pedro Lopes">



    <!-- Retro Theme Styles -->
    <link rel="stylesheet" href="./static/css/retro-theme.css">
    <link rel="stylesheet" href="./static/css/windows95.css">
    <link rel="stylesheet" href="./static/css/curve-inspired.css">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="./static/favicon.ico">

    
</head>
<body>
    <!-- Desktop with Retro Background -->
    <div class="desktop-wrapper">
        <!-- Main Window Chrome -->
        <div class="window-chrome">
            <!-- Title Bar -->
            <div class="title-bar">
                <span class="title-text">
                    Pedro Lopes - Choosing a Garbage Collector for Your Java/Kotlin Application: Things I Wish I Knew Back Then
                </span>
                <div class="window-controls">
                    <button class="btn-minimize" aria-label="Minimize">_</button>
                    <button class="btn-maximize" aria-label="Maximize">‚ñ°</button>
                    <button class="btn-close" aria-label="Close">√ó</button>
                </div>
            </div>

            <!-- Menu Bar / Navigation -->
            <nav class="menu-bar">
                <a href="https://pedroca.xyz">Home</a>
                
                <a href="tags.html">Tags</a>
                
                <a href="archive.html">Archive</a>
                
                <a href="authors.html">Authors</a>
                
            </nav>

            <!-- Main Content Area -->
            <main class="content-area">
                
<article class="window-panel">
    <!-- Post Header -->
    <header class="post-header">
        <h1 class="post-title">Choosing a Garbage Collector for Your Java/Kotlin Application: Things I Wish I Knew Back Then</h1>

        <div class="post-meta">
            

            
            <span class="post-author">
                üë§ by <a href="author-pedrohbl_.html">Pedro Lopes</a>
            </span>
            

            
            <div class="post-tags">
                
                
                <a href="tag-java.html" class="retro-badge">java</a>
                
                
                <a href="tag-garbage-collector.html" class="retro-badge">garbage-collector</a>
                
                
                <a href="tag-kotlin.html" class="retro-badge">kotlin</a>
                
                
                <a href="tag-jvm.html" class="retro-badge">jvm</a>
                
            </div>
            
        </div>
    </header>

    <!-- Post Content -->
    <div class="post-content">
        <p>Jan 12, 2025 - ‚ßñ 10 min</p>
<h2 id="introduction">Introduction</h2>
<p>When I first started building Java and Kotlin applications, I didn‚Äôt really pay much attention to garbage collection. It was this magical process that "just worked." But as I moved into more complex systems‚Äîbatch processing, high-throughput APIs, and distributed architectures‚ÄîI realized that choosing the right garbage collector could make or break my application‚Äôs performance, and also prevent some later production incidents.</p>
<p>Some of my early APIs even experienced breakdowns due to memory leaks, leading to unresponsive systems under heavy load. These episodes taught me the critical importance of understanding how GC works and how to configure it for specific workloads. Failing to consider GC for high-throughput APIs, for example, can lead to severe latency spikes, memory fragmentation, or outright crashes.</p>
<p>This article is a guide for those who, like me, wish they had a clearer understanding of JVM garbage collectors earlier. I will try to cover:</p>
<ol>
<li>How garbage collection works in the JVM.</li>
<li>The different types of GCs available.</li>
<li>Real-world use cases and configs for each GC.</li>
<li>Choosing the right garbage collector (references for informed decision-making).</li>
<li>Conclusion &amp; Exercises ;-).</li>
</ol>
<p>Let‚Äôs dive in and make garbage collection work <em>for</em> you, not against you.</p>
<hr />
<h2 id="how-garbage-collection-works-in-the-jvm">How Garbage Collection Works in the JVM</h2>
<p>Garbage collection in the JVM is all about managing heap memory(imagine it's the playground where all your objects live). When objects are no longer referenced, they become eligible for garbage collection, freeing up memory for new allocations. But the process isn‚Äôt always seamless‚ÄîGC pauses and overhead can significantly impact performance.</p>
<h3 id="key-concepts">Key Concepts</h3>
<h4 id="heap-memory">Heap Memory</h4>
<ol>
<li>
<p><strong>Eden Space (in the Young Generation):</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> This is where new objects are first allocated.</p>
</li>
<li><strong>Garbage Collection Behavior:</strong> Objects in Eden are short-lived and quickly collected during a minor GC cycle if they are no longer in use.</li>
<li>
<p><strong>Example:</strong> Suppose you‚Äôre creating multiple instances of a <code>Minion</code> class. And those minions are from <em>League of Legends</em> or <em>Despicable Me</em>‚Äîyour choice:</p>
<p><code>for (int i = 0; i &lt; 1000; i++) {
     Minion minion = new Minion("Minion " + i);
 }</code></p>
<p>All these minions will initially be created in the Eden space. If they are not referenced anymore after their creation, they will be collected during the next minor GC.
2. <strong>Survivor Spaces (in the Young Generation):</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Objects that survive one or more minor GC cycles in Eden are moved to Survivor spaces.</p>
</li>
<li><strong>Garbage Collection Behavior:</strong> Survivor spaces act as a staging area before objects are promoted to the Old Generation.</li>
<li><strong>Example:</strong> In a game application, temporary data like dead minions or player movement logs might survive for a short time in Survivor spaces before being discarded or promoted if reused frequently.</li>
<li>
<p><strong>Old Generation:</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Objects that have a long lifespan or survive multiple minor GC cycles are moved to the Old Generation.</p>
</li>
<li><strong>Garbage Collection Behavior:</strong> Garbage collection here is less frequent but more time-consuming.</li>
<li>
<p><strong>Example:</strong> Imagine you‚Äôre building a game where each <code>Player</code> represents a connected user on the match. These objects are long-lived compared to temporary data like minions or projectiles and may look like this:</p>
<p>```
 public class Player {
     private final String name;
     private final Inventory inventory;</p>
<div class="codehilite"><pre><span></span><code> public Player(String name) {
     this.name = name;
     this.inventory = new Inventory();
 }
</code></pre></div>

<p>}
 ```</p>
<p>A <code>Player</code> object, which holds data such as the player‚Äôs inventory and stats, will likely reside in the Old Generation as it persists for the entire application session.
4. <strong>Metaspace:</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Think of Metaspace as the library(outside the heap) of your application‚Äîit keeps the blueprints (class metadata) for all the objects your application creates.</p>
</li>
<li><strong>Garbage Collection Behavior:</strong> Metaspace grows dynamically as new class loaders are introduced and is cleaned up when those class loaders are no longer needed. This ensures that unused blueprints don‚Äôt mess up your libraries.</li>
<li>
<p><strong>Example:</strong> Imagine you‚Äôre running a game that supports mods, and players can load new heroes dynamically. Each mod represents a new class dynamically loaded at runtime:</p>
<p><code>Class&lt;?&gt; heroClass = Class.forName("com.game.dynamic.Hero");
 Object hero = heroClass.getDeclaredConstructor().newInstance();</code></p>
<p>The blueprint for the <code>Hero</code> class will be stored in Metaspace. When the mod is unloaded or the player exits the game, the class loader is no longer needed, and the JVM will clean up the associated Metaspace memory. This ensures that your application remains efficient, even with dynamic features.</p>
</li>
</ol>
<h4 id="garbage-collector-phases">Garbage Collector Phases</h4>
<ol>
<li>
<p><strong>Mark:</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Identify live objects by traversing references starting from the root set (e.g., static fields, local variables).</p>
</li>
<li>
<p><strong>Practical Example:</strong> Consider this code:</p>
<p><code>Player player = new Player("Hero");
 player.hitMinion();</code></p>
<p>The <code>player</code> object is reachable because it‚Äôs referenced in the method. During the Mark phase, the GC identifies <code>player</code> and its dependencies as live objects.
2. <strong>Sweep:</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Reclaim memory occupied by objects not marked as live.</p>
</li>
<li>
<p><strong>Practical Example:</strong> If the <code>player</code> reference is set to <code>null</code>:</p>
<p><code>player = null;</code></p>
<p>The next GC cycle‚Äôs Sweep phase will reclaim the memory occupied by the <code>player</code> object and its associated data.
3. <strong>Compact:</strong></p>
</li>
<li>
<p><strong>Purpose:</strong> Reduce fragmentation by moving objects closer together in memory.</p>
</li>
<li>
<p><strong>Practical Example:</strong> After reclaiming memory, gaps may exist in the heap. Compacting ensures efficient allocation for future objects:</p>
<p><code>// Before compaction: [Minion 1][   ][Minion 3][   ]
 // After compaction:  [Minion 1][Minion 3][       ]</code></p>
<p>This step is particularly important in systems with frequent allocations and deallocations(Related to CPU efficiency).</p>
</li>
</ol>
<p>For a deep understanding, the JVM GC documentation provides wider insights (<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/">source</a>).</p>
<hr />
<h2 id="types-of-jvm-garbage-collectors">Types of JVM Garbage Collectors</h2>
<h3 id="1-serial-garbage-collector-serial-gc">1. Serial Garbage Collector (Serial GC)</h3>
<h4 id="overview">Overview:</h4>
<p>The Serial GC is single-threaded and optimized for simplicity. It processes the Young and Old Generations one at a time, pausing application threads during GC.</p>
<h4 id="when-to-use">When to Use:</h4>
<ul>
<li>VERY SMALL applications with SINGLE-THREAD workloads.</li>
<li>Low-memory environments (e.g., embedded systems).</li>
</ul>
<h4 id="limitations">Limitations:</h4>
<ul>
<li>Not suitable for high-concurrency, high-throughput systems.</li>
<li>Maximum throughput is low due to its single-threaded nature.</li>
</ul>
<h4 id="example">Example:</h4>
<p>Consider a system managing API calls for IoT devices that periodically send sensor data (e.g., room temperature). Each device sends minimal data in a predictable pattern, and the system handles only one request per thread. The Serial GC ensures predictable, low-overhead memory management, making it an ideal choice for such an environment.</p>
<h4 id="docker-example">Docker Example:</h4>
<div class="codehilite"><pre><span></span><code>FROM openjdk:17-jdk-slim
CMD java -XX:+UseSerialGC -Xmx512m -jar app.jar
</code></pre></div>

<hr />
<h3 id="2-parallel-garbage-collector-parallel-gc">2. Parallel Garbage Collector (Parallel GC)</h3>
<h4 id="overview_1">Overview:</h4>
<p>Parallel GC, also known as the Throughput Collector, uses multiple threads to speed up garbage collection. It aims to maximize application throughput by minimizing the total GC time. You can check some crazy a** graphs and get better explanation at the official documentation <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#gen_arrangement_parallel">here</a>.</p>
<h4 id="when-to-use_1">When to Use:</h4>
<ul>
<li>Batch processing systems.</li>
<li>Applications prioritizing throughput over low latency.</li>
</ul>
<h4 id="example_1">Example:</h4>
<p>Imagine a financial service API that consolidates transactions into daily reports. Since the workload prioritizes throughput over latency, Parallel GC is ideal for processing large transaction sets efficiently.</p>
<h4 id="docker-example_1">Docker Example:</h4>
<div class="codehilite"><pre><span></span><code>FROM openjdk:17-jdk-slim
CMD java -XX:+UseParallelGC -Xmx2g -jar app.jar
</code></pre></div>

<hr />
<h3 id="3-g1-garbage-collector-g1gc">3. G1 Garbage Collector (G1GC)</h3>
<h4 id="overview_2">Overview:</h4>
<p>G1GC divides the heap into regions and collects garbage incrementally, making it a good balance between throughput and low latency.</p>
<h4 id="when-to-use_2">When to Use:</h4>
<ul>
<li>General-purpose applications.</li>
<li>Systems requiring predictable pause times.</li>
</ul>
<h4 id="example_2">Example:</h4>
<p>Any SaaS platform serving user requests in under 200ms with moderate traffic spikes.</p>
<h4 id="docker-example_2">Docker Example:</h4>
<div class="codehilite"><pre><span></span><code>FROM openjdk:17-jdk-slim
CMD java -XX:+UseG1GC -Xmx4g -XX:MaxGCPauseMillis=200 -jar app.jar
</code></pre></div>

<h4 id="important-considerations-about-g1gc">Important considerations about G1GC:</h4>
<p>You might be wondering: "If G1GC supports both good throughput and low latency, why not use it for every application? Sounds like a no-brainer..."</p>
<p>But well, not quite. While G1GC is a fantastic general-purpose garbage collector, it‚Äôs not the universal solution for all workloads. Think of it as the "jack of all trades" of GCs‚Äîgood at many things, but not necessarily the best at any one thing. <em>Poof!</em> Now that you‚Äôre out of the cave, let‚Äôs analyze:</p>
<ul>
<li><strong>Throughput-Focused Applications:</strong> If your application doesn‚Äôt care about pause times‚Äîfor example, batch processing systems or data aggregation pipelines‚Äîwhy would you burden it with G1GC‚Äôs incremental collection overhead? Parallel GC is better suited here, offering raw performance without worrying about predictable pauses.</li>
<li><strong>Ultra-Low Latency Needs:</strong> If you‚Äôre building a real-time trading system or managing huge heaps (think terabytes), G1GC might struggle to meet your strict latency requirements. Collectors like ZGC or Shenandoah GC are designed specifically for these use cases, offering sub-10ms pause times.</li>
</ul>
<p>In short, G1GC is like that versatile tool in your toolbox‚Äîit works well for a variety of tasks, especially if you‚Äôre building the classic CRUD API (yes pretty much all of your messy simple Spring CRUDs). But if you‚Äôre running specialized workloads, you‚Äôll want to pick a collector that‚Äôs optimized to your needs.</p>
<hr />
<h3 id="4-z-garbage-collector-zgc">4. Z Garbage Collector (ZGC)</h3>
<h4 id="overview_3">Overview:</h4>
<p>ZGC is designed for ultra-low-latency applications with large heaps (up to terabytes). Its pause times are typically under 10 milliseconds.</p>
<h4 id="when-to-use_3">When to Use:</h4>
<ul>
<li>Real-time systems.</li>
<li>Applications with very large heaps.</li>
</ul>
<h4 id="when-to-do-not-use">When to DO NOT use:</h4>
<ul>
<li>Imagine you have a batch processing system using ZGC. There is very high chance of facing inceased CPU utilization($$$) without any latency benefit. For example, a data ingestion pipeline optimized for high throughput but insensitive to pause times would waste resources managing unnecessary low-latency GC cycles.</li>
</ul>
<h4 id="example_3">Example:</h4>
<p>A trading system processing market data streams in real time.</p>
<h4 id="docker-example_3">Docker Example:</h4>
<div class="codehilite"><pre><span></span><code>FROM openjdk:17-jdk-slim
CMD java -XX:+UseZGC -Xmx16g -jar app.jar
</code></pre></div>

<hr />
<h3 id="5-shenandoah-garbage-collector">5. Shenandoah Garbage Collector</h3>
<h4 id="overview_4">Overview:</h4>
<p>Shenandoah GC minimizes pause times by performing concurrent compaction. It‚Äôs ideal for latency-sensitive applications.</p>
<h4 id="when-to-use_4">When to Use:</h4>
<ul>
<li><strong>Payment gateways</strong> with strict SLA requirements for latency.</li>
<li><strong>APIs with spiky traffic</strong> patterns, such as social media feeds or live voting systems.</li>
<li>Applications where reducing GC pause time is critical to user experience, such as gaming servers or interactive web applications.</li>
</ul>
<h4 id="when-to-do-not-use_1">When to DO NOT use:</h4>
<p>Using Shenandoah GC for batch processing systems or workloads optimized for high throughput over low latency (e.g., nightly data aggregation) may lead to inefficient CPU utilization. The additional overhead of concurrent compaction provides no benefits when predictable pauses are acceptable, reducing overall throughput compared to <strong>Parallel GC</strong>.</p>
<p>For exampe, a financial reconciliation batch process configured with Shenandoah might experience reduced throughput due to unnecessary focus on low pause times, delaying report generation.</p>
<h4 id="example_4">Example:</h4>
<p>A payment processing API handling high transaction volumes cannot afford GC-induced latency spikes during peak hours. Shenandoah‚Äôs low-pause nature ensures that transaction processing continues smoothly even under heavy load.</p>
<p>Another example is a real-time multiplayer gaming server, where latency spikes could lead to a poor player experience. Shenandoah ensures consistent frame updates and server responsiveness.</p>
<h4 id="docker-example_4">Docker Example:</h4>
<div class="codehilite"><pre><span></span><code>FROM openjdk:17-jdk-slim
CMD java -XX:+UseShenandoahGC -Xmx8g -XX:+UnlockExperimentalVMOptions -jar app.jar
</code></pre></div>

<hr />
<h2 id="choosing-the-right-garbage-collector">Choosing the Right Garbage Collector</h2>
<p>Here you can find a cheatsheet. But remember... you should always evaluate your own workload before choosing it's garbage collector.</p>
<table>
<thead>
<tr>
<th>Garbage Collector</th>
<th>Best For</th>
<th>JVM Version Support</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial GC</td>
<td>Small, single-threaded apps</td>
<td>All versions</td>
</tr>
<tr>
<td>Parallel GC</td>
<td>High-throughput batch systems</td>
<td>All versions</td>
</tr>
<tr>
<td>G1GC</td>
<td>General-purpose apps</td>
<td>Java 9+</td>
</tr>
<tr>
<td>ZGC</td>
<td>Real-time, large heap apps</td>
<td>Java 11+</td>
</tr>
<tr>
<td>Shenandoah GC</td>
<td>Low-latency apps</td>
<td>Java 11+</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="conclusion">Conclusion</h2>
<p>Choosing the right garbage collector for your application requires some knowledge over the tools I discussed in this post. But once you learn about it, you may have the power of taking decisions, and this is extremely valuable in Software Engineering field, also, by selecting the right GC you can significantly improve performance, stability and save some costs for your future applications based on JVM. Don‚Äôt let GC be a black box‚Äîembrace it, tune it, and let it work for you.</p>
<hr />
<h2 id="training-real-world-scenarios-and-solutions">Training: Real-World Scenarios and Solutions</h2>
<h3 id="scenario-1-payment-gateway-latency">Scenario 1: Payment Gateway Latency</h3>
<p>You are building a payment gateway API that must process transactions in real-time with strict SLA requirements. The workload is spiky, with heavy traffic during sales events or specific times of the day. Which garbage collector would you choose to ensure low latency?</p>
<h3 id="scenario-2-batch-data-processing-system">Scenario 2: Batch Data Processing System</h3>
<p>Your application processes daily financial reconciliation batches, which involve large amounts of data. Latency is not a concern, but throughput must be maximized to complete processing as fast as possible. Which garbage collector fits this use case?</p>
<h3 id="scenario-3-real-time-multiplayer-game">Scenario 3: Real-Time Multiplayer Game</h3>
<p>You are designing a server for a real-time multiplayer game. The server must manage thousands of players, each generating events continuously. Latency spikes during garbage collection are unacceptable as they could lead to lag and a poor user experience. What GC configuration would you use?</p>
<hr />
<h2 id="solutions">Solutions</h2>
<h3 id="solution-1-payment-gateway-latency">Solution 1: Payment Gateway Latency</h3>
<p>Use <strong>Shenandoah GC</strong> to ensure low latency and consistent response times. Its concurrent compaction minimizes pause times, making it ideal for latency-sensitive workloads.</p>
<h3 id="solution-2-batch-data-processing-system">Solution 2: Batch Data Processing System</h3>
<p>Use <strong>Parallel GC</strong> to maximize throughput. Since latency isn‚Äôt a concern, the Parallel GC‚Äôs focus on high efficiency during garbage collection fits this workload.</p>
<h3 id="solution-3-real-time-multiplayer-game">Solution 3: Real-Time Multiplayer Game</h3>
<p>Use <strong>ZGC</strong> to achieve ultra-low latency and scale with large heaps. It ensures that garbage collection does not interfere with real-time gameplay.</p>
<h3 id="references">References:</h3>
<ol>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/">Java Garbage Collection Basics - Oracle</a></li>
</ol>
<hr />
<ul>
<li><a href="author-pedrohbl_.html"><img alt="Pedro Lopes" src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" />
  Pedro Lopes</a></li>
</ul>
<p>Jan 12, 2025 - ‚ßñ 10 min</p>
<ul>
<li><a href="./tag-java.html">java</a></li>
<li><a href="./tag-garbage-collector.html">garbage-collector</a></li>
<li><a href="./tag-kotlin.html">kotlin</a></li>
<li><a href="./tag-jvm.html">jvm</a></li>
</ul>
    </div>

    <!-- Post Footer with Navigation -->
    
    <footer class="post-footer" style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.1);">
        <div style="display: flex; justify-content: space-between; gap: 1rem;">
            
            <a href="immutable-databases.html" class="button" style="flex: 1;">
                ‚Üê Immutable Databases: When Data Never Dies
            </a>
            

            
            <a href="2025-01-12.html" class="button" style="flex: 1; text-align: right;">
                 ‚Üí
            </a>
            
        </div>
    </footer>
    

    <!-- Author Info -->
    
    <div class="curve-card" style="margin-top: 2rem; padding: 1.5rem;">
        <h3>About the Author</h3>
        <div style="display: flex; gap: 1rem; align-items: center;">
            
            <img src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" alt="Pedro Lopes" style="width: 60px; height: 60px; border-radius: 50%;">
            
            <div>
                <strong>Pedro Lopes</strong>
                <p style="margin: 0.5rem 0; color: var(--text-secondary);">Software Engineer =D</p>
                
                <div style="display: flex; gap: 0.5rem;">
                    
                    <a href="https://www.linkedin.com/in/pedro-lopes-4563a7196/" class="retro-badge" target="_blank" rel="noopener">Linkedin</a>
                    
                </div>
                
            </div>
        </div>
    </div>
    
</article>

<!-- Related Posts (if available) -->


            </main>

            <!-- Footer / Status Bar -->
            <footer class="status-bar">
                <div>Powered by <a href="https://github.com/rochacbruno/marmite">Marmite</a> | <small><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY_NC-SA</a></small></div>
            </footer>
        </div>
    </div>

    <!-- Retro Effects & Main JavaScript -->
    <script src="./static/js/retro-effects.js"></script>
    <script src="./static/js/main.js"></script>

    
</body>
</html>