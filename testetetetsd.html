<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light" />
    <meta name="generator" content="Marmite Retro Edition" />

    <title>How Monads and Functional Programming Can Improve Your Exception Handling in Kotlin - Pedro Lopes</title>

    
<meta property="og:title" content="How Monads and Functional Programming Can Improve Your Exception Handling in Kotlin">
<meta property="og:description" content=" Introduction If you&#39;ve been programming in Kotlin or Java, you&#39;re probably used to handling errors ...">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Pedro Lopes">


<meta property="article:author" content="Pedro Lopes">



    <!-- Retro Theme Styles -->
    <link rel="stylesheet" href="./static/css/retro-theme.css">
    <link rel="stylesheet" href="./static/css/windows95.css">
    <link rel="stylesheet" href="./static/css/curve-inspired.css">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="./static/favicon.ico">

    
</head>
<body>
    <!-- Desktop with Retro Background -->
    <div class="desktop-wrapper">
        <!-- Main Window Chrome -->
        <div class="window-chrome">
            <!-- Title Bar -->
            <div class="title-bar">
                <span class="title-text">
                    Pedro Lopes - How Monads and Functional Programming Can Improve Your Exception Handling in Kotlin
                </span>
                <div class="window-controls">
                    <button class="btn-minimize" aria-label="Minimize">_</button>
                    <button class="btn-maximize" aria-label="Maximize">‚ñ°</button>
                    <button class="btn-close" aria-label="Close">√ó</button>
                </div>
            </div>

            <!-- Menu Bar / Navigation -->
            <nav class="menu-bar">
                <a href="https://pedroca.xyz">Home</a>
                
                <a href="tags.html">Tags</a>
                
                <a href="archive.html">Archive</a>
                
                <a href="authors.html">Authors</a>
                
            </nav>

            <!-- Main Content Area -->
            <main class="content-area">
                
<article class="window-panel">
    <!-- Post Header -->
    <header class="post-header">
        <h1 class="post-title">How Monads and Functional Programming Can Improve Your Exception Handling in Kotlin</h1>

        <div class="post-meta">
            

            
            <span class="post-author">
                üë§ by <a href="author-pedrohbl_.html">Pedro Lopes</a>
            </span>
            

            
            <div class="post-tags">
                
                
                <a href="tag-kotlin.html" class="retro-badge">kotlin</a>
                
                
                <a href="tag-exception.html" class="retro-badge">exception</a>
                
                
                <a href="tag-functional-programming.html" class="retro-badge">functional-programming</a>
                
                
                <a href="tag-haskell.html" class="retro-badge">haskell</a>
                
            </div>
            
        </div>
    </header>

    <!-- Post Content -->
    <div class="post-content">
        <p>Feb 18, 2025 - ‚ßñ 14 min</p>
<h2 id="introduction">Introduction</h2>
<p>If you've been programming in Kotlin or Java, you're probably used to handling errors with <code>try-catch</code> blocks. While this approach is standard, it can become really messy in complex scenarios, leading to verbose and difficult-to-maintain code. More critically, traditional exception handling forces developers to constantly anticipate where exceptions might be thrown, increasing cognitive load and potential oversight.</p>
<p>Functional programming offers a powerful set of tools for improving code quality, especially when it comes to error handling. The goal here is to focus on the core concepts that can help you write cleaner, more robust, and more predictable error-handling code. I‚Äôm not here to dive into Haskell or push its philosophical depths‚Äîhonestly, being really honest I‚Äôm very afraid of the Haskell nerds in general. Instead, I‚Äôll explore how these functional programming ideas can be practically applied in Kotlin, with real-world use cases in mind.</p>
<p>One such concept is the <strong>monad</strong>, which provides a structured approach to handling side effects, errors, and sequencing operations. In Kotlin, while not purely functional, it can achieve some of these principles through libraries like <a href="https://github.com/michaelbull/kotlin-result">kotlin-result</a>.</p>
<p>Basically, in this post I'll try to cover:</p>
<ol>
<li><strong>Why traditional exception handling can be problematic.</strong></li>
<li><strong>Core functional programming concepts relevant to error handling.</strong></li>
<li><strong>How <code>kotlin-result</code> addresses these concerns.</strong></li>
<li><strong>Designing APIs with Error Handling in Mind</strong></li>
<li><strong>Addressing the errors listed in 1 using <code>kotlin-result</code> and functional programming concepts.</strong></li>
</ol>
<h2 id="the-problem-traditional-exception-handling">The Problem: Traditional Exception Handling</h2>
<p>Traditional exception handling introduces several issues that can compromise code clarity, reliability, and make it a complete mess. Below I've listed some common problematic uses:</p>
<ul>
<li><strong>Hidden Control Flow:</strong> Exception-based error handling introduces invisible jumps in your code execution, making it hard to follow:</li>
</ul>
<p><code>fun processUser(user: User) {
      validateUser(user)
      updateProfile(user)
      notifyUser(user)
  }</code></p>
<p>Any of these functions could throw an exception, turning the flow unpredictable. This way, Raymond Chen from Microsoft describes exceptions as "Exceptions are like non-local goto statements" which results in:</p>
<ul>
<li>Hard-to-trace execution paths.</li>
<li>Unintended disruptions.</li>
<li>Increased difficulty in ensuring consistent error handling.</li>
</ul>
<p>A better approach would make errors explicit and handle them systematically.
* <strong>The Checked vs. Unchecked Dilemma:</strong> Checked exceptions in Java force developers to catch and handle exceptions at every step, cluttering codebases:</p>
<p><code>try {
      fileOperation()  // throws IOException
      networkCall()    // throws NetworkException
      dbOperation()    // throws SQLException
  } catch (IOException e) {
      // Handle file error
  } catch (NetworkException e) {
      // Handle network error
  } catch (SQLException e) {
      // Handle DB error
  }</code></p>
<p>Unchecked exceptions, while more flexible, introduce uncertainty, as function signatures do not explicitly indicate possible failure cases.
* <strong>Resource Management Complexity:</strong> Managing resources manually often leads to nested <code>try-finally</code> blocks that makes code difficult to maintain and understand later on:</p>
<p><code>fun processOrders() {
      val connection = dataSource.connection
      try {
          val statement = connection.createStatement()
          try {
              val result = statement.executeQuery("SELECT * FROM orders")
              try {
                  // Process result
              } finally {
                  result.close()
              }
          } finally {
              statement.close()
          }
      } finally {
          connection.close()
      }
  }</code></p>
<p>This structure is:</p>
<ul>
<li>Verbose and difficult to read.</li>
<li>Vulnerable to resource leaks if exceptions are not handled correctly.</li>
<li>Hard to maintain.</li>
</ul>
<p>This just looks ugly overall, let's be honest.
* <strong>Loss of Type Safety:</strong> Traditional exceptions break type safety because failure conditions are not represented in function signatures:</p>
<p><code>fun getUserProfile(id: String): UserProfile {
      // This function might throw exceptions that aren‚Äôt apparent from the signature. That's one of the most important points of the post
      throw new UserNotFoundException()
  }</code></p>
<p>This approach:</p>
<ul>
<li>Leads to unexpected runtime failures.</li>
<li>Reduces predictability in API contracts.</li>
<li>Makes error handling an afterthought instead of a first-class concern.</li>
</ul>
<h2 id="core-functional-programming-concepts-relevant-to-error-handling">Core Functional Programming Concepts Relevant to Error Handling</h2>
<h3 id="what-is-functional-programming">What is Functional Programming?</h3>
<p>Functional programming is a paradigm where functions are treated as first-class citizens, and computation is done through the evaluation of EXPRESSIONS rather than the execution of statements(like mostly done in imperative languages C, java, cpp...). It emphasizes immutability, no side effects, and the use of pure functions. This paradigm, while vast with numerous research areas like lambda calculus, category theory, and type systems, provides a lot of nerdy tools for managing complexity in software.
I'd recommend this lecture if you want to dive deeper in some o these topics or if you really hate yourself -&gt; "Learn You a Haskell for Great Good!" by Miran Lipovaca (<a href="http://learnyouahaskell.com/">link</a>) and <a href="https://www.haskell.org/">Haskell.org</a> for deeper dives into functional concepts.</p>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Immutability:</strong> Data cannot be changed once created, promoting safer parallel processing.</li>
<li><strong>Pure Functions:</strong> Functions always produce the same output for the same input, without affecting or being affected by the external behaviors.</li>
<li><strong>Higher-Order Functions:</strong> Functions can take other functions as arguments or return them.</li>
</ul>
<p>This post will focus only on a few of on how these concepts, particularly functors and monads.</p>
<h3 id="functors-safe-value-transformations">Functors: Safe Value Transformations</h3>
<p>Functor is like a box or container. You can apply a transformation (or function) to what's inside the box without opening it. In programming terms, this means you can alter or map over the contents of a data structure without changing its structure:</p>
<ul>
<li><strong>List as a Functor:</strong> If you have a list of numbers, you can double each number without altering the list itself:</li>
</ul>
<p><code>val numbers = listOf(1, 2, 3)
    val doubled = numbers.map { it * 2 } // [2, 4, 6]</code>
* <strong>Conceptually:</strong> Functors allow you to work with data in a way that's safe and predictable because you're not directly manipulating the data but rather transforming it through a mapping operation.</p>
<h3 id="monads-chaining-operations-with-context">Monads: Chaining Operations with Context</h3>
<p>Monads extend the concept of functors by allowing operations to be chained together while preserving some form of 'context' or 'state':</p>
<ul>
<li><strong>Monad:</strong> Monads help to ensure that each step in the sequence is checked before proceeding. It sounds complex(and it possibly is a little bit) but it's a way to wrapping things and provide methods to do operations on the wrapped stuff without unwrapping it.</li>
</ul>
<p>Let's take an example to make it more practical, consider monads as the operation of baking a cake. You need flour before you can add eggs. If there's no flour, you don't add the eggs.
* <strong>In Code:</strong> Monads provide a way to wrap values in context, manage that context through operations, and decide on the next step based on the outcome of the previous one:</p>
<p><code>val maybeFlour = checkForFlour()
    val maybeCake = maybeFlour.flatMap { flour -&gt; 
        if (flour) {
            addEggs()
        } else {
            Result.failure(NoFlourException())
        }
    }</code>
* <strong>Practical Use:</strong> In error handling, monads can encapsulate whether an operation was successful or not, allowing you to sequence operations where one depends on the success of another without explicit exception checks.</p>
<h2 id="how-kotlin-result-addresses-these-concerns">How <code>kotlin-result</code> Addresses These Concerns</h2>
<p><code>kotlin-result</code> is a Kotlin library that encapsulates the monadic approach to error handling, offering a <code>Result</code> type which is <strong>a monadic type that holds either a successful value or an error</strong>. Here's how it adress some issues:</p>
<ul>
<li><strong>Explicit Success or Failure:</strong> Rather than using exceptions, <code>Result</code> explicitly represents outcomes as either success (<code>Result.Success</code>) or failure (<code>Result.Failure</code>). This makes error paths clear and predictable, every call should return success or failure.</li>
<li><strong>Type-Safe Error Handling:</strong> By leveraging sealed classes for error types, <code>kotlin-result</code> ensures at compile-time that all possible outcomes are accounted for. This prevents runtime surprises, similar to how a monadic type system ensures all paths are considered.</li>
<li><strong>Reduces Error Boilerplate:</strong> The library allows operations to be chained with methods like <code>map</code>, <code>flatMap</code>, or <code>andThen</code>. This reduces the need for extensive <code>try-catch</code> blocks, promoting cleaner code by handling errors in a functional manner.</li>
<li><strong>Resource Management:</strong> Combining Kotlin's scope functions with <code>Result</code> simplifies resource management. Operations can ensure resources are released properly, even on failure, without the clutter of nested <code>try-finally</code> blocks.</li>
<li><strong>Promotes Composable Code:</strong> Functions return <code>Result</code> types, enabling them to be composed into more complex operations. This modularity and reusability reflect the functional programming ethos of treating functions as building blocks.</li>
</ul>
<h3 id="key-use-cases">Key Use Cases</h3>
<ul>
<li><strong>Replacing Traditional Exception Handling:</strong> When you want to avoid exceptions for scenarios where error is part of the normal flow, like input validation or network calls. Instead of exceptions, you return <code>Result</code> to explicitly handle both success and failure.</li>
<li><strong>API Design:</strong> When designing APIs, <code>kotlin-result</code> helps in creating interfaces that are clear about what can go wrong, allowing clients to handle errors gracefully without exception handling boilerplate.</li>
<li><strong>Error Propagation:</strong> In large codebases, propagating errors up the call stack can be done in a way that's clear and doesn't rely on exceptions, making the code easier to reason about.</li>
</ul>
<h3 id="solving-common-problems">Solving Common Problems</h3>
<ul>
<li><strong>Hidden Control Flow:</strong> By making errors explicit, <code>kotlin-result</code> prevents the "invisible jumps" in code execution that exceptions can cause.</li>
<li><strong>Checked vs. Unchecked Exceptions:</strong> With <code>Result</code>, you don't need to choose between the verbosity of checked exceptions or the uncertainty of unchecked exceptions; instead, you model errors as part of your function's return type :)</li>
<li><strong>Resource Management Complexity:</strong> Using <code>Result</code> with Kotlin's scope functions, resource management becomes part of the happy path, simplifying code and reducing the chance of resource leaks.</li>
<li><strong>Loss of Type Safety:</strong> Since <code>Result</code> includes errors in its type definition, function signatures become more informative, ensuring that error handling is considered from the get-go.</li>
</ul>
<h2 id="designing-apis-with-error-handling-in-mind">Designing APIs with Error Handling in Mind</h2>
<p>When you're designing your Kotlin APIs, consider the following to ensure your error handling is effective:</p>
<ul>
<li><strong>Use Exceptions only when strictly needed:</strong> Reserve exceptions for true programming errors where recovery is not feasible, like accessing an index out of bounds in an array. These signify bugs that should be caught and reported, not handled routinely.</li>
<li><strong>Use <code>Result</code> for Flow:</strong> For scenarios where failure is part of normal operation (like validation, network calls, or data parsing), return <code>Result</code> types. This makes error handling explicit, giving you control over how failures are managed without resorting to exceptions.</li>
<li><strong>Wrap logic and adapt it:</strong> When you're interfacing with legacy or external APIs that throw exceptions for conditions that aren't logic errors, wrap these calls. Create functions that transform exceptions into <code>Result</code> types, giving your API users a cleaner, more predictable interface:</li>
</ul>
<p>```
    fun fetchUserData(userId: Int): Result<UserData, NetworkError> {
        return try {
            Result.success(api.getUserData(userId))
        } catch (e: IOException) {
            Result.failure(NetworkError.IOError(e.message ?: "Network error"))
        } catch (e: TimeoutException) {
            Result.failure(NetworkError.Timeout("Request timed out"))
        }
    }</p>
<div class="codehilite"><pre><span></span><code>//<span class="w"> </span>Where<span class="w"> </span>NetworkError<span class="w"> </span>could<span class="w"> </span>be<span class="w"> </span>defined<span class="w"> </span>as:
sealed<span class="w"> </span>class<span class="w"> </span>NetworkError<span class="w"> </span>{
<span class="w">    </span>data<span class="w"> </span>class<span class="w"> </span>IOError(val<span class="w"> </span>message:<span class="w"> </span>String)<span class="w"> </span>:<span class="w"> </span>NetworkError()
<span class="w">    </span>data<span class="w"> </span>class<span class="w"> </span>Timeout(val<span class="w"> </span>message:<span class="w"> </span>String)<span class="w"> </span>:<span class="w"> </span>NetworkError()
}
</code></pre></div>

<p>```
* <strong>Multiple Error Scenarios:</strong> For functions that can fail in various ways, define a sealed class to represent these outcomes:</p>
<p><code>sealed class InputError {
        data class Empty(val field: String) : InputError()
        data class InvalidFormat(val field: String, val reason: String) : InputError()
        data class OutOfRange(val field: String) : InputError()
    }</code></p>
<h2 id="addressing-the-errors-listed-in-first-section-using-kotlin-result">Addressing the Errors Listed in first section Using <code>kotlin-result</code></h2>
<h3 id="example-1-hidden-control-flow">Example 1: Hidden Control Flow</h3>
<p>Instead of implicit exception flow:</p>
<ul>
<li><strong>Problem:</strong> Exceptions make execution unpredictable‚Äîany call could derail the flow.</li>
<li><strong>Solution with <code>Result</code>:</strong> Make every step of the process explicit:</li>
</ul>
<p><code>fun processUser(user: User): Result&lt;ProcessedUser, UserError&gt; =
        validateUser(user)
            .andThen { updateProfile(it) }
            .andThen { notifyUser(it) }</code>
* <strong>Why It Works:</strong> Instead of invisible jumps, each function returns a <code>Result</code>, letting you handle success or failure explicitly. The flow stays linear and predictable, directly addressing the "non-local goto" issue.</p>
<h3 id="example-2-checked-vs-unchecked-dilemma">Example 2: Checked vs. Unchecked Dilemma</h3>
<ul>
<li><strong>Problem:</strong> Checked exceptions bloat code; unchecked ones hide risks.</li>
<li><strong>Solution with <code>Result</code>:</strong> Define clear error types:</li>
</ul>
<p>```
    sealed class UserError {
        data class ValidationError(val reason: String) : UserError()
        data class NetworkError(val message: String) : UserError()
    }</p>
<div class="codehilite"><pre><span></span><code>fun validateUser(user: User): Result&lt;ValidUser, UserError.ValidationError&gt;
fun notifyUser(user: UpdatedUser): Result&lt;ProcessedUser, UserError.NetworkError&gt;
</code></pre></div>

<p>```
* <strong>Why It Works:</strong> This avoids the verbosity of checked exceptions and the uncertainty of unchecked ones. Errors are part of the signature, making failure modes explicit and manageable, resolving the dilemma cleanly.</p>
<h3 id="example-3-resource-management-complexity">Example 3: Resource Management Complexity</h3>
<ul>
<li><strong>Problem:</strong> Managing resources with <code>try-finally</code> blocks are verbose and leak-prone.</li>
<li><strong>Solution with <code>Result</code>:</strong> Combine <code>Result</code> with Kotlin functions <code>use</code>:</li>
</ul>
<p><code>fun processOrders(): Result&lt;List&lt;Order&gt;, DBError&gt; =
        dataSource.connection.use { connection -&gt;
            connection.createStatement().use { statement -&gt;
                statement.executeQuery("SELECT * FROM orders").use { result -&gt;
                    runCatching { result.toOrders() }
                        .mapError { DBError.QueryFailed(it.message) }
                }
            }
        }</code>
* <strong>Why It Works:</strong> <code>use</code> auto-closes resources, and <code>Result</code> captures errors, eliminating nesting. This directly simplifies the ugly, error-prone structure from before.</p>
<h3 id="example-4-loss-of-type-safety">Example 4: Loss of Type Safety</h3>
<ul>
<li><strong>Problem:</strong> Exceptions hide failure modes, breaking type safety.</li>
<li><strong>Solution with <code>Result</code>:</strong> Functions return <code>Result</code> with explicit error type:</li>
</ul>
<p><code>fun getUserProfile(id: String): Result&lt;UserProfile, UserFetchError&gt; = try {
        Result.success(database.getUserProfile(id))
    } catch (e: SQLException) {
        Result.failure(UserFetchError.DatabaseError(e.message ?: "Unknown error"))
    }</code>
* <strong>Why It Works:</strong> The signature now declares possible failures, ensuring errors are handled upfront. This eliminates runtime surprises and strengthens the API contract, fixing the type safety gap.</p>
<h2 id="conclusion-rethinking-exception-handling-with-purpose">Conclusion: Rethinking Exception Handling with Purpose</h2>
<p>Functional programming and monads, via <code>kotlin-result</code>, transform error handling into something explicit, type-safe, and composable. They tackle hidden control flow with clear paths, resolve the checked/unchecked mess with typed errors, simplify resource management, and restore type safety‚Äîall while boosting readability and maintainability.</p>
<p>So, when should you go for <code>Result</code> or <code>try-catch</code>?</p>
<ul>
<li>
<p><strong>Use <code>Result</code>:</strong></p>
</li>
<li>
<p>For <strong>expected failures</strong> in normal flow: validation errors, network timeouts, or parsing issues. These are business logic concerns where you want fine-grained control and explicit outcomes in your code.</p>
</li>
<li>When designing <strong>APIs or libraries</strong>, to give users predictable, exception-free contracts.</li>
<li>In <strong>functional pipelines</strong>, where chaining operations with error propagation feels natural.</li>
<li>
<p><strong>Use <code>try-catch</code> (Exceptions):</strong></p>
</li>
<li>
<p>For <strong>unexpected, unrecoverable errors</strong>: null dereferences, file corruption, or logic bugs. These signal something‚Äôs broken, not a routine failure, and are best caught at a higher level (e.g., app-wide handlers).</p>
</li>
<li>When working with <strong>legacy code</strong> or external APIs that throw exceptions, and wrapping them in <code>Result</code> isn‚Äôt practical yet.</li>
<li>For <strong>centralized recovery</strong>, like logging crashes or restarting a service, where granular handling isn‚Äôt the goal.</li>
</ul>
<p>Think of it this way: <code>Result</code> is for errors you <em>plan to handle locally</em>, while exceptions are for errors you <em>escalate or crash on</em>. Roman Elizarov‚Äôs take on Kotlin‚Äôs exception philosophy (<a href="https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07">link</a>) echoes this: exceptions are for the exceptional, not the everyday.</p>
<p>**This post draws inspiration from Roman Elizarov's insightful discussion on Kotlin's exception handling philosophy, which can be found <a href="https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07">here</a>.</p>
<h2 id="references">References</h2>
<ul>
<li>Bull, Michael. <em>kotlin-result</em>. GitHub repository. <a href="https://github.com/michaelbull/kotlin-result">https://github.com/michaelbull/kotlin-result</a>.</li>
<li>Chen, Raymond. "Exceptions are like non-local goto statements" (paraphrased concept). Commonly referenced in discussions on exception handling, e.g., Microsoft Developer Blogs.</li>
<li>Elizarov, Roman. "Kotlin and Exceptions." Medium, 2021. <a href="https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07">https://elizarov.medium.com/kotlin-and-exceptions-8062f589d07</a>.</li>
<li>Lipovaca, Miran. <em>Learn You a Haskell for Great Good!</em> Online book. <a href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a>.</li>
<li>Haskell Community. <em>Haskell Official Website</em>. <a href="https://www.haskell.org/">https://www.haskell.org/</a>.</li>
</ul>
<hr />
<ul>
<li><a href="author-pedrohbl_.html"><img alt="Pedro Lopes" src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" />
  Pedro Lopes</a></li>
</ul>
<p>Feb 18, 2025 - ‚ßñ 14 min</p>
<ul>
<li><a href="./tag-kotlin.html">kotlin</a></li>
<li><a href="./tag-exception.html">exception</a></li>
<li><a href="./tag-functional-programming.html">functional-programming</a></li>
<li><a href="./tag-haskell.html">haskell</a></li>
</ul>
    </div>

    <!-- Post Footer with Navigation -->
    
    <footer class="post-footer" style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.1);">
        <div style="display: flex; justify-content: space-between; gap: 1rem;">
            
            <a href="understanding-lambdas.html" class="button" style="flex: 1;">
                ‚Üê date: 2025-04-09
            </a>
            

            
            <a href="test.html" class="button" style="flex: 1; text-align: right;">
                How Monads and Functional Programming Can Improve Your Exception Handling in Kotlin ‚Üí
            </a>
            
        </div>
    </footer>
    

    <!-- Author Info -->
    
    <div class="curve-card" style="margin-top: 2rem; padding: 1.5rem;">
        <h3>About the Author</h3>
        <div style="display: flex; gap: 1rem; align-items: center;">
            
            <img src="https://s3.us-east-1.amazonaws.com/pedroca.io/pedropedroca.jpg" alt="Pedro Lopes" style="width: 60px; height: 60px; border-radius: 50%;">
            
            <div>
                <strong>Pedro Lopes</strong>
                <p style="margin: 0.5rem 0; color: var(--text-secondary);">Software Engineer =D</p>
                
                <div style="display: flex; gap: 0.5rem;">
                    
                    <a href="https://www.linkedin.com/in/pedro-lopes-4563a7196/" class="retro-badge" target="_blank" rel="noopener">Linkedin</a>
                    
                </div>
                
            </div>
        </div>
    </div>
    
</article>

<!-- Related Posts (if available) -->


            </main>

            <!-- Footer / Status Bar -->
            <footer class="status-bar">
                <div>Powered by <a href="https://github.com/rochacbruno/marmite">Marmite</a> | <small><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY_NC-SA</a></small></div>
            </footer>
        </div>
    </div>

    <!-- Retro Effects & Main JavaScript -->
    <script src="./static/js/retro-effects.js"></script>
    <script src="./static/js/main.js"></script>

    
</body>
</html>